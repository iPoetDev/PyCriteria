#!/user/bin/env python3
# pylint: disable=trailing-whitespace
# ruff: noqa: F841, ANN101, ANN001, D415, RET505, I001,
"""Module: PyCriteria Logging.

This module contains the logging configuration for the PyCriteria package.
This module was code generated assisted / generated by PerplexityAI
https://www.perplexity.ai/search/56ba87c6-09f7-4451-a106-7b5aa99a3231?s=criteria

:class: ConnectionLogger
:class: AppLogger

:imports: sys, Literal, loguru

"""

import click
import rich
import scapy.layers.inet
import scapy.layers.inet6
from loguru import logger as loggr
from scapy.all import *


class ConnectionLogger:
    """ConnectionLogger Class.: for logging GSpread and Remote connections
    
    Initialises a Loguru logger and
    adds a file handler to log messages to a file named "gspread.log".
    The log_request method logs an HTTP request, and the log_socket method logs a socket.
    
    :method log_request: Log a HTTP request.
    :method log_socket: Log a local socket.
    :method log_connection: Log a connection., switch by mode
    """
    
    def __init__(self, verbosity: bool = True, compression: str = "zip", size: str = "10 MB"):
        self.logger = loggr
        self.logger.add("connection.log",
                        rotation=size,
                        compression=compression,
                        diagnose=verbosity,
                        backtrace=verbosity,
                        catch=verbosity)
    
    def log_request(self, request):
        """Log a HTTP request."""
        self.logger.debug(f"HTTP request: {request}")
    
    def log_socket(self, socket):
        """Log a local socket."""
        self.logger.debug(f"Socket: {socket}")
    
    def log_connection(self,
                       response: str = "",
                       socket: str = "",
                       mode: Literal["http", "socket", "verbose"] = "http"):
        """Log a connection., switch by type"""
        if mode == "http":
            self.logger.info(f"HTTP connection: {response}")
        elif mode == "socket":
            self.logger.info(f"Socket connection: {socket}")
        elif mode == "verbose":
            self.logger.info(f"Verbose connection: {response}")
            self.logger.info(f"Socket connection: {socket}")


class AppLogger:
    """AppLogger Class.
    
     Initialises a Loguru logger and adds two handlers:
     1: one that logs messages to a file named "app.log" and
     2: another that logs messages to the console.
        The log methods logs a message at the INFO level.
        
    :method log: Log a message at the INFO level.
    :method remote: Log a message at the INFO level.
    """
    filesink: str = "app.log"
    infoformat: str = "INFO: {time} {level} {message}"
    debugformat: str = "DEBUG: {time} {level} {message}"
    compression: str = "zip"
    httpget: str = "GET /api/data HTTP/1.1"
    socket: str = "192.168.0.46:8080"
    color: bool = True
    
    def __init__(self, sink: str = "", httprequest: str = "",
                 socket: str = "",
                 verbosity: bool = True,
                 compression: str = "zip",
                 rotation: str = "10 MB"):
        # Set Properties
        self.filesink = sink if sink != "" else self.filesink
        self.httpget = httprequest if httprequest != "" else self.httpget
        self.socket = socket if socket != "" else self.socket
        # Loguru logger
        self.logger = loggr
        # File handler
        self.logger.add("app.log",
                        rotation=rotation,
                        compression=self.compression,
                        diagnose=verbosity,
                        catch=verbosity)
        # Console handler
        self.logger.add(sys.stderr,
                        format=self.infoformat,
                        colorize=self.color,
                        diagnose=verbosity,
                        backtrace=verbosity,
                        catch=verbosity)
        # Connection Logging
        self.connection = ConnectionLogger(
                verbosity=verbosity,
                compression=compression,
                size=rotation)
    
    def log(self,
            message,
            mode: Literal["http", "socket", "verbose"] = "http"):
        """Log a message at the INFO level."""
        # self.logger.info(message)
        self.logger.debug(message)
        if mode == "http":
            self.connection.log_request(message)
        elif mode == "socket":
            self.connection.log_socket(message)
    
    def remote(self,
               message,
               mode: Literal["http", "socket", "verbose"] = "http"):
        """Log a message at the INFO level."""
        if mode == "http":
            self.connection.log_request(message)
        elif mode == "socket":
            self.connection.log_socket(message)
    
    def streamconfig(self, verbosity: bool = True):
        """Stream configuration."""
        self.logger.add(lambda record: record["message"],
                        level="DEBUG",
                        format=self.debugformat,
                        colorize=self.color,
                        diagnose=verbosity,
                        backtrace=verbosity,
                        catch=verbosity)
    
    def stream(self, detail="debug"):
        self.streamconfig()
        """Stream."""
        if detail == "debug":
            self.logger.debug("Stream DEBUG")
        elif detail == "info":
            self.logger.info("Stream INFO")
        elif detail == "warning":
            self.logger.warning("Stream WARN")
        elif detail == "error":
            self.logger.error("Stream ERROR")
        elif detail == "critical":
            self.logger.critical("Stream CRITICAL")
        else:
            click.echo(f"Invalid detail level.{detail}")
    
    # HTTP Traficing Sniffing, which is a bit risky for ToS for Cloud Platforms
    # Is used here to build local traffic logs for the app only.
    # while testing
    # https://www.perplexity.ai/search/74ecfeeb-a2f4-49bd-87fa-bf2d6d575899?s=c
    # Do not deploy this code or functionality to a cloud platform.
    
    def httpsniff(self, pacet):
        """HTTP Sniffer."""
        if pacet.haslayer(scapy.layers.inet.TCP) and pacet.haslayer(Raw):
            payload = pacet[Raw].load.decode(errors='ignore')
            if "HTTP" in payload:
                http_payload = payload[payload.index(["HTTP"]):]
                http_code = http_payload.split()[1]
                rich.print(f'{http_code}:__ {http_payload}', flush=True)
    
    # End: clilogging.py
    
    def sniffsniff(self, filterlevel: int = 3, capture: int = 0):
        """Sniffer."""
        
        def configd(switchcap: int):
            if switchcap == 1:
                conf.use_pcap = True
            elif switchcap == 2:
                conf.use_npcap = True
            else:
                click.echo(f"Invalid capture level.{switchcap}")
        
        def sniffed(level: int):
            if level == 0:
                filtr = "tcp port 80"
                sniff(filter=filtr, prn=self.httpsniff)
            elif level == 1:
                filtr = "tcp port 80 or tcp port 443"
                sniff(filter=filtr, prn=self.httpsniff)
            elif level == 2:
                filtr = "tcp port 80 or tcp port 443 or tcp port 8080"
                sniff(filter=filtr, prn=self.httpsniff)
            elif level == 3:
                filtr = "tcp port 80 or tcp port 443 or tcp port 8080 or tcp port 8081"
                sniff(filter=filtr, prn=self.httpsniff)
            elif level == 4:
                filtr = "tcp port 80 or tcp port 443 or tcp port 445 or tcp port 8080 or tcp port 8081"
                sniff(filter=filtr, prn=self.httpsniff)
        
        configd(switchcap=2)
        sniffed(level=filterlevel)

# End: clilogging.py
